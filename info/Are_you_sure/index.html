<!DOCTYPE html>
<html lang="ko">
<head>
  <style>html { scroll-behavior: auto !important; }</style>
  <meta charset="UTF-8" />
  <title>Info | shovideo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="color-scheme" content="dark light">
  <link rel="icon" href="/favicon-light.ico" sizes="any" media="(prefers-color-scheme: light)">
  <link rel="icon" href="/favicon-dark.ico"  sizes="any" media="(prefers-color-scheme: dark)">
  <link rel="icon" href="/favicon.ico" sizes="any">

  <style>
    :root {
      --header-h: 56px;
      --bg: #0f1115;
      --panel: #1b1f2a;
      --text: #e9eef5;
      --muted: #9aa4b2;
      --track: #6b7280; /* gray */
      --thumb: #0a0a0b; /* black */
      --ctrl-h: 26px;   /* ë²„íŠ¼/ìŠ¬ë¼ì´ë” ê³µí†µ ë†’ì´ */
    }
    
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: sans-serif;
      /* ìš”ì²­: í˜ì´ì§€ ê¸°ë³¸ ìŠ¤í¬ë¡¤ ë¹„í™œì„±í™” (PDF ì˜ì—­ë§Œ ìŠ¤í¬ë¡¤) */
      overflow: hidden;
    }
    
    header {
      position: sticky; top:0; z-index:1000;
      height: var(--header-h);
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:8px 12px; background:#111622;
      border-bottom:1px solid rgba(255,255,255,0.1);
    }
    .title { font-weight: 600; white-space: nowrap; }
    
    /* ì»¨íŠ¸ë¡¤ ë¬¶ìŒ */
    .controls {
      margin-left:auto;
      display:flex; align-items:center; gap:8px;
      min-width: 320px;
    }
    .iconbtn {
      display:inline-flex; align-items:center; justify-content:center;
      height: var(--ctrl-h); aspect-ratio: 1/1;
      background:var(--panel); color:var(--text);
      border:none; padding:0; border-radius:8px; cursor:pointer;
    }
    .iconbtn svg { width: 18px; height: 18px; fill: currentColor; }

    /* ìŠ¬ë¼ì´ë” + ë¼ë²¨ í•œ ì…‹ */
    .zoombar {
      display:flex; align-items:center; gap:10px;
      background: transparent;
      padding: 0;
      height: var(--ctrl-h);
      min-width: 220px;
    }
    .zoombar input[type="range"]{
      -webkit-appearance: none; appearance: none;
      width: 180px; height: var(--ctrl-h); /* íŠ¸ë™ê³¼ ìŠ¬ë¼ì´ë” ë™ì¼ ë†’ì´ */
      background: transparent;
    }
    /* íŠ¸ë™: íšŒìƒ‰, ë†’ì´ = ì»¨í…Œì´ë„ˆ ë†’ì´ì™€ ë™ì¼ */
    .zoombar input[type="range"]::-webkit-slider-runnable-track{
      height: 100%; 
      background: var(--track);
      border-radius:9999px;
    }
    .zoombar input[type="range"]::-moz-range-track{
      height: 100%;
      background: var(--track);
      border-radius: 9999px;
    }
    /* ìŠ¬ë¼ì´ë”(thumb): ê²€ì€ìƒ‰ ì›í˜• + bevel */
    .zoombar input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none; appearance: none;
      width: var(--ctrl-h); height: var(--ctrl-h);
      background: var(--thumb);
      border-radius: 50%;
      box-shadow:
        inset 2px 2px 4px rgba(255,255,255,0.18),
        inset -3px -3px 6px rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.08);
      margin-top: 0; /* íŠ¸ë™ ë†’ì´ì™€ ë™ì¼í•˜ë¯€ë¡œ 0 */
    }
    .zoombar input[type="range"]::-moz-range-thumb{
      width: var(--ctrl-h); height: var(--ctrl-h);
      background: var(--thumb);
      border-radius: 50%;
      box-shadow:
        inset 2px 2px 4px rgba(255,255,255,0.18),
        inset -3px -3px 6px rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .zoom-badge{
      display:inline-flex; align-items:center; justify-content:center;
      height: var(--ctrl-h);
      padding: 0 10px;
      background: var(--panel);
      border-radius: 9999px;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
      font-size: 13px;
      min-width: 64px; /* 100% ê³ ì •í­ ëŠë‚Œ */
    }

    /* ë·°í¬íŠ¸: ì¢Œìš°/ìƒí•˜ ìŠ¤í¬ë¡¤ì„ ì—¬ê¸°ì„œ ì²˜ë¦¬ */
    #pdf-viewport{
      width: 100vw;
      height: calc(100vh - var(--header-h));
      overflow: auto; /* í™•ëŒ€ ì‹œ ì¢Œìš° ìŠ¤í¬ë¡¤ ê°€ëŠ¥ */
      box-sizing: border-box;
    }

    /* ì»¨í…Œì´ë„ˆ: ê¸°ë³¸ 80vw, ë‚´ë¶€ ì¤‘ì•™ ì •ë ¬ */
    #pdf-container {
      width: 80vw;
      margin: 0 auto;
      padding: 16px 16px 48px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100%;
    }

    /* PDF í˜ì´ì§€ ìº”ë²„ìŠ¤: ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ í¬í•¨ */
    canvas {
      display: block;
      margin: 0 0 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
      background: #fff;
      border-radius: 6px;
      opacity: 0;
      transform: translateY(40px);
      transition: opacity .6s ease, transform .6s ease;
    }
    canvas.show { opacity: 1; transform: translateY(0); }

    /* ëª¨ë°”ì¼: ì»¨íŠ¸ë¡¤ì„ ì œëª© ì•„ë˜ë¡œ ì´ë™(í•œ ì¤„ ë”) */
    @media (max-width: 768px){
      header { height: auto; align-items: flex-start; }
      .title { width: 100%; margin-bottom: 6px; }
      .controls { width: 100%; margin-left: 0; flex-wrap: wrap; }
      .zoombar { flex: 1; min-width: 0; }
      #pdf-viewport{ height: calc(100vh - 84px); }
    }
  </style>
</head>
<body>

<!-- HARD WHEEL INTERCEPT (smart host) -->
<script>
(function(){
  if (window.__ScrollEaseHard) return;
  window.__ScrollEaseHard = true;

  const ROOT = document.scrollingElement || document.documentElement;
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));

  const friction  = 0.85;
  const wheelBoost= 0.12;
  const maxSpeed  = 10;
  const wheelCap  = 60;
  const stopEps   = 0.16;

  function isScrollable(el, dy){
    if (!el || el === document || el === document.documentElement) return false;
    const cs = getComputedStyle(el);
    if (!(cs.overflowY === 'auto' || cs.overflowY === 'scroll')) return false;
    if (el.scrollHeight <= el.clientHeight + 1) return false;
    if (dy > 0)  return el.scrollTop + el.clientHeight < el.scrollHeight;
    if (dy < 0)  return el.scrollTop > 0;
    return true;
  }
  function findHost(target, dy){
    for (let n = target; n; n = n.parentElement){
      if (isScrollable(n, dy)) return n;
    }
    return ROOT;
  }

  let host = ROOT, vy = 0, raf = 0;
  const max = (el) => el === ROOT
    ? Math.max(0, ROOT.scrollHeight - innerHeight)
    : Math.max(0, el.scrollHeight - el.clientHeight);

  function tick(){
    if (Math.abs(vy) > stopEps){
      vy *= friction;
      const step = clamp(vy, -10, 10);
      const next = clamp(Math.round(host.scrollTop + step), 0, max(host));
      if (next !== host.scrollTop) host.scrollTop = next;
      raf = requestAnimationFrame(tick);
    } else {
      vy = 0; raf = 0;
    }
  }

  function onWheel(e){
    // â˜… pdf-viewport ì•ˆì—ì„œëŠ” ê°€ë¡œ/ì„¸ë¡œ ë„¤ì´í‹°ë¸Œ ìŠ¤í¬ë¡¤ ì¡´ì¤‘ (ì¶©ëŒ íšŒí”¼)
    if (e.target && (e.target.closest && e.target.closest('#pdf-viewport'))){
      return; // ê¸°ë³¸ ë™ì‘ ìœ ì§€
    }

    const raw = e.deltaY || 0; if (!raw) return;
    host = findHost(e.target, raw) || ROOT;
    e.preventDefault();
    const d = clamp(raw, -wheelCap, wheelCap);
    vy += d * wheelBoost;
    if (!raf) raf = requestAnimationFrame(tick);
  }

  function onKey(e){
    const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
    if (tag === 'input' || tag === 'textarea' || e.defaultPrevented) return;

    let add = 0, h = innerHeight;
    if (e.key === 'ArrowDown') add = +56;
    else if (e.key === 'ArrowUp') add = -56;
    else if (e.key === 'PageDown' || (e.key === ' ' && !e.shiftKey)) add =  h * 0.9;
    else if (e.key === 'PageUp'   || (e.key === ' ' &&  e.shiftKey)) add = -h * 0.9;
    else if (e.key === 'Home')    { host = ROOT; ROOT.scrollTop = 0; return; }
    else if (e.key === 'End')     { host = ROOT; ROOT.scrollTop = max(ROOT); return; }

    if (add !== 0){
      e.preventDefault();
      host = ROOT;
      vy += add;
      if (!raf) raf = requestAnimationFrame(tick);
    }
  }

  [window, document, document.documentElement].forEach(t=>{
    t && t.addEventListener('wheel', onWheel, { capture:true, passive:false });
  });
  function attachBody(){
    if (document.body)
      document.body.addEventListener('wheel', onWheel, { capture:true, passive:false });
  }
  if (document.body) attachBody();
  else document.addEventListener('DOMContentLoaded', attachBody, { once:true });

  window.addEventListener('keydown', onKey, { passive:false });

  window.__SE = { info(){ return { host: (host===ROOT?'ROOT':'EL'), vy, anim: !!raf }; } };
})();
</script>

<header>
  <button class="iconbtn" onclick="history.back()" title="Back" aria-label="Back" style="padding:0 10px; aspect-ratio:auto;">
    â†
  </button>
  <span class="title">Video Information</span>

  <!-- ì»¨íŠ¸ë¡¤ ë¬¶ìŒ(ë°ìŠ¤í¬í†±ì€ ìš°ì¸¡, ëª¨ë°”ì¼ì€ ì•„ë˜ ì¤„ë¡œ) -->
  <div class="controls" id="controls">
    <!-- Zoom Out (SVG í‘ë°±) -->
    <button id="zoomOutBtn" class="iconbtn" aria-label="Zoom out" title="Zoom out">
      <!-- minus glass -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M10.5 3a7.5 7.5 0 0 1 5.93 12.19l4.19 4.19-1.41 1.41-4.19-4.19A7.5 7.5 0 1 1 10.5 3Zm0 2a5.5 5.5 0 1 0 0 11A5.5 5.5 0 0 0 10.5 5Zm-3 5h6v2h-6z"/>
      </svg>
    </button>

    <!-- Zoom Slider + Label -->
    <div class="zoombar">
      <input id="zoomSlider" type="range" min="0.25" max="3.0" step="0.01" value="1.00" aria-label="Zoom slider" />
    </div>

    <span class="zoom-badge" id="zoomLabel">100%</span>

    <!-- Fit -->
    <button id="fitBtn" class="iconbtn" aria-label="Fit to 80vw" title="Fit to 80vw" style="padding:0 10px; aspect-ratio:auto;">
      â¤¢
    </button>

    <!-- Zoom In (SVG í‘ë°±) -->
    <button id="zoomInBtn" class="iconbtn" aria-label="Zoom in" title="Zoom in">
      <!-- plus glass -->
      <svg viewBox="0 0 24 24" aria-hidden="true">
        <path d="M10.5 3a7.5 7.5 0 0 1 5.93 12.19l4.19 4.19-1.41 1.41-4.19-4.19A7.5 7.5 0 1 1 10.5 3Zm0 2a5.5 5.5 0 1 0 0 11A5.5 5.5 0 0 0 10.5 5Zm-3.5 5.5h3v-3h2v3h3v2h-3v3h-2v-3h-3z"/>
      </svg>
    </button>
  </div>
</header>

<!-- ë·°í¬íŠ¸ ë˜í¼: ì¢Œìš°/ìƒí•˜ ìŠ¤í¬ë¡¤ í—ˆìš© -->
<div id="pdf-viewport">
  <main id="pdf-container">Loading PDF...</main>
</div>

<!-- PDF.js -->
<script type="module">
  import * as pdfjsLib from './pdfjs/pdf.mjs';
  pdfjsLib.GlobalWorkerOptions.workerSrc = './pdfjs/pdf.worker.mjs';

  // ===== ê²½ë¡œ ìœ í‹¸ =====
  function __folderFromPath() {
    let path = location.pathname.replace(/\/+$/, '');
    const parts = path.split('/').filter(Boolean);
    if (!parts.length) return '';
    let last = parts[parts.length - 1];
    if (/\.html?$/i.test(last)) {
      parts.pop();
      last = parts[parts.length - 1] || '';
    }
    return last;
  }
  const __FOLDER = __folderFromPath();
  const PDF_URL = `/assets/PDF/${encodeURIComponent(__FOLDER)}.pdf`;

  // ===== ì—˜ë¦¬ë¨¼íŠ¸ =====
  const viewportEl = document.getElementById('pdf-viewport');
  const container = document.getElementById('pdf-container');
  const zoomInBtn  = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const fitBtn     = document.getElementById('fitBtn');
  const zoomSlider = document.getElementById('zoomSlider');
  const zoomLabel  = document.getElementById('zoomLabel');

  // ===== ìŠ¤ì¼€ì¼ íŒŒë¼ë¯¸í„° =====
  const MIN_SCALE = 0.25;
  const MAX_SCALE = 3.0;
  const ZOOM_STEP = 0.1;

  let pdfDoc = null;
  let basePageWidth = null;    // PDF 100% viewport width (scale=1)
  let scale = 1;               // CSS í‘œì‹œ ìŠ¤ì¼€ì¼
  let fitMode = true;          // true = 80vw ë§ì¶¤
  let firstRendered = false;

  // ë Œë” í’ˆì§ˆ íƒ€ê¹ƒ (ìš”êµ¬ 3)
  const BASE_LONG = 1920; // 1080pê¸‰ (ê¸´ ë³€)
  const HI_LONG   = 2560; // 2Kê¸‰ (ê¸´ ë³€)
  // í˜„ì¬ CSS í¬ê¸° ê¸°ì¤€ìœ¼ë¡œ ìº”ë²„ìŠ¤ í”½ì…€ ë°°ìœ¨ ê³„ì‚°
  function computeOutScale(cssW, cssH){
    const longCss = Math.max(cssW, cssH);
    const targetLong = (scale > 1.0) ? HI_LONG : BASE_LONG;
    let s = targetLong / longCss;
    // ë„ˆë¬´ ê³¼í•œ ë°°ìœ¨ ë³´í˜¸ (GPU ë©”ëª¨ë¦¬ ëŒ€ë¹„)
    const DPR = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
    // DPRì˜ 2ë°°ê¹Œì§€ëŠ” í—ˆìš© (ì•ˆí‹°ì•¨ë¦¬ì–´ì‹± í’ˆì§ˆ í™•ë³´)
    s = Math.min(s, DPR * 2.0);
    return s;
  }

  // ê³µìš© ìœ í‹¸
  const cssPx = (v) => `${Math.round(v * 100) / 100}px`;
  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  function getInnerWidth(el){
    const cs = getComputedStyle(el);
    const pad = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    return el.clientWidth - pad;
  }
  
  function updateContainerWidth(){
    const pageCssW = basePageWidth ? basePageWidth * scale : getInnerWidth(viewportEl);
  
    if (fitMode){
      // í™”ë©´ë§ì¶¤: 80vw ìœ ì§€ + ê°€ìš´ë°
      container.style.width = '80vw';
      container.style.margin = '0 auto';
      container.style.alignItems = 'center';    // ìº”ë²„ìŠ¤ ê°€ìš´ë° ì •ë ¬
    } else {
      // í™•ëŒ€ ëª¨ë“œ: ì»¨í…Œì´ë„ˆë¥¼ í˜ì´ì§€ í­ìœ¼ë¡œ ëŠ˜ë¦¬ê³ , ì¢Œì¸¡ ì •ë ¬(ê°€ì¥ ì¤‘ìš”)
      const target = Math.max(pageCssW, getInnerWidth(viewportEl));
      container.style.width = cssPx(target);
      container.style.margin = '0';             // auto ì œê±° â†’ ì¢Œì¸¡ ê¸°ì¤€
      container.style.alignItems = 'flex-start';// ìº”ë²„ìŠ¤ ì™¼ìª½ ì •ë ¬
    }
  }
  
  function computeScaleFit(){
    const w = getInnerWidth(container); // 80vw ë‚´ë¶€í­
    if (!basePageWidth) return 1;
    return w / basePageWidth;
  }
  function debounce(fn, ms = 150){ let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), ms); }; }

  // ë“±ì¥ ì• ë‹ˆë©”ì´ì…˜ ì˜µì €ë²„
  const appearObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting){
        entry.target.classList.add('show');
        appearObserver.unobserve(entry.target);
      }
    });
  }, { threshold: 0.1 });

  // í˜ì´ì§€ ë Œë”ë§
  async function renderPage(pageNum){
    const page = await pdfDoc.getPage(pageNum);
    const viewport = page.getViewport({ scale });

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // CSS í‘œì‹œ í¬ê¸°
    const cssW = viewport.width;
    const cssH = viewport.height;

    // outScaleì€ ìš”êµ¬ 3ì— ë§ì¶° í’ˆì§ˆ íƒ€ê¹ƒìœ¼ë¡œ ê³„ì‚° (ì´ˆê¸° 1080p, 100% ì´ˆê³¼ì‹œ 2K)
    const outScale = computeOutScale(cssW, cssH);

    canvas.width  = Math.floor(cssW  * outScale);
    canvas.height = Math.floor(cssH  * outScale);
    canvas.style.width  = cssPx(cssW);
    canvas.style.height = cssPx(cssH);

    const renderContext = {
      canvasContext: ctx,
      viewport,
      transform: outScale !== 1 ? [outScale, 0, 0, outScale, 0, 0] : null
    };

    await page.render(renderContext).promise;
    container.appendChild(canvas);
    appearObserver.observe(canvas);
  }

  async function renderAll(){
    container.innerHTML = '';
    for (let n = 1; n <= pdfDoc.numPages; n++){
      await renderPage(n);
    }
    firstRendered = true;
  }

  // ìŠ¤í¬ë¡¤ ìœ„ì¹˜ ë¹„ìœ¨ ë³´ì¡´(ì¤Œ ì‹œ)
  function rememberScrollRatio(){
    const el = viewportEl; // ì „ì²´ ë¬¸ì„œ ëŒ€ì‹  ë·°í¬íŠ¸ ê¸°ì¤€
    const maxY = Math.max(1, el.scrollHeight - el.clientHeight);
    const maxX = Math.max(1, el.scrollWidth  - el.clientWidth);
    return { ry: el.scrollTop / maxY, rx: el.scrollLeft / maxX };
  }
  function restoreScrollRatio(r){
    const el = viewportEl;
    const maxY = Math.max(1, el.scrollHeight - el.clientHeight);
    const maxX = Math.max(1, el.scrollWidth  - el.clientWidth);
    el.scrollTo({ top: r.ry * maxY, left: r.rx * maxX, behavior: 'auto' });
  }

  // ì´ˆê¸° ë¡œë“œ
  (async () => {
    try {
      pdfDoc = await pdfjsLib.getDocument(PDF_URL).promise;
      const page1 = await pdfDoc.getPage(1);
      basePageWidth = page1.getViewport({ scale: 1 }).width;

      // 80vw ê¸°ì¤€ í™”ë©´ë§ì¶¤ ìŠ¤ì¼€ì¼
      scale = computeScaleFit();
      // ì´ˆê¸° ë Œë”ëŠ” 1080p íƒ€ê¹ƒìœ¼ë¡œ ì¶œë ¥ (computeOutScale ë‚´ ë¡œì§ì´ ì²˜ë¦¬)
      updateContainerWidth();
      await renderAll();
      updateZoomUI();
    } catch (e) {
      console.error(e);
      container.textContent = 'PDF load failed ğŸ˜¢';
    }
  })();

  // ë¦¬ì‚¬ì´ì¦ˆ (fit ëª¨ë“œì—ì„œë§Œ ìë™ ì¬ê³„ì‚°)
  const onResize = debounce(async () => {
    if (!pdfDoc || !basePageWidth || !fitMode) return;
    const nextFit = computeScaleFit();
    if (Math.abs(nextFit - scale) < 0.02) return;
    scale = nextFit;
    updateContainerWidth();
    await renderAll();
    updateZoomUI();
  }, 200);
  window.addEventListener('resize', onResize);
  new ResizeObserver(onResize).observe(container);

  // === ì»¨íŠ¸ë¡¤ ===
  function updateZoomUI(){
    // ê¸°ì¤€: "100%"ëŠ” scale=1 (PDF ê³ ìœ  100%)
    const pct = Math.round(scale * 100);
    zoomLabel.textContent = `${pct}%`;
    // ìŠ¬ë¼ì´ë”ëŠ” 0.25~3.0 ì‚¬ì´ì—ì„œ í˜„ scale í‘œì‹œ
    const v = clamp(scale, MIN_SCALE, MAX_SCALE);
    zoomSlider.value = v.toFixed(2);
  }

  async function setScale(newScale, keepScroll=true){
    newScale = clamp(newScale, MIN_SCALE, MAX_SCALE);
    const ratio = keepScroll ? rememberScrollRatio() : null;
    scale = newScale;
    updateContainerWidth();    // â˜… ì¶”ê°€
    await renderAll();
    if (ratio) restoreScrollRatio(ratio);
    updateZoomUI();
  }

  async function doZoom(delta){
    fitMode = false;
    await setScale(+(scale + delta).toFixed(2), true);
  }

  zoomInBtn?.addEventListener('click',  () => doZoom(+ZOOM_STEP));
  zoomOutBtn?.addEventListener('click', () => doZoom(-ZOOM_STEP));

  // ìŠ¬ë¼ì´ë” â†’ ìŠ¤ì¼€ì¼ ì—°ë™
  zoomSlider?.addEventListener('input', async (e)=>{
    fitMode = false;
    const val = parseFloat(e.target.value);
    await setScale(val, true);
  });

  // Fit to 80vw
  fitBtn?.addEventListener('click', async () => {
    fitMode = true;
    updateContainerWidth();
    await setScale(computeScaleFit(), false);
    viewportEl.scrollTo({ top: 0, left: 0, behavior: 'auto' });
  });

  // Ctrl+0 â†’ Fit
  window.addEventListener('keydown', (e) => {
    if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
      e.preventDefault();
      fitMode = true;
      updateContainerWidth();
      await setScale(computeScaleFit(), false);
      // ë˜ëŠ”
      fitMode = true;
      setScale(computeScaleFit(), false).then(()=>{
        updateContainerWidth();
        viewportEl.scrollTo({ top:0, left:0, behavior:'auto' });
    }
  });

  // Shift+Wheel â†’ ê°€ë¡œ ìŠ¤í¬ë¡¤ (ë·°í¬íŠ¸ ë‚´ë¶€ì—ì„œë§Œ)
  viewportEl.addEventListener('wheel', (e)=>{
    if (!e.shiftKey) return;
    // ë¸Œë¼ìš°ì € ê¸°ë³¸: shift+wheel == ê°€ë¡œìŠ¤í¬ë¡¤ì´ì§€ë§Œ, ë” ê°•í•˜ê²Œ ë°€ì–´ì¤Œ
    e.preventDefault();
    viewportEl.scrollLeft += e.deltaY;
  }, { passive:false });

  // Space+ë“œë˜ê·¸ â†’ íŒ¨ë‹ (ë§ˆìš°ìŠ¤ íŠ¸ë™íŒ¨ë“œ ê³µìš©)
  let spacePanning = false, panStart = null;
  window.addEventListener('keydown', (e)=>{ if (e.code === 'Space') { spacePanning = true; document.body.style.cursor='grab'; } });
  window.addEventListener('keyup',   (e)=>{ if (e.code === 'Space') { spacePanning = false; document.body.style.cursor=''; } });
  viewportEl.addEventListener('mousedown', (e)=>{
    if (!spacePanning) return;
    e.preventDefault();
    panStart = { x:e.clientX, y:e.clientY, sx: viewportEl.scrollLeft, sy: viewportEl.scrollTop };
    document.body.style.cursor='grabbing';
  });
  window.addEventListener('mousemove', (e)=>{
    if (!panStart) return;
    const dx = e.clientX - panStart.x;
    const dy = e.clientY - panStart.y;
    viewportEl.scrollTo({ left: panStart.sx - dx, top: panStart.sy - dy });
  });
  window.addEventListener('mouseup', ()=>{
    if (panStart){ panStart=null; document.body.style.cursor= spacePanning ? 'grab' : ''; }
  });

  // (ì„ íƒ) í„°ì¹˜ í•€ì¹˜-ì¤Œì€ ë‚˜ì¤‘ì— ë„£ì–´ë„ ë˜ì§€ë§Œ, ëª¨ë°”ì¼ì—ì„  ìŠ¬ë¼ì´ë”/ë²„íŠ¼ìœ¼ë¡œ ì¶©ë¶„.
  // í•„ìš”í•´ì§€ë©´ PointerEvents ë‘ ì†ê°€ë½ ê±°ë¦¬ ê¸°ë°˜ìœ¼ë¡œ setScale() í˜¸ì¶œí•˜ëŠ” í•¸ë“¤ëŸ¬ ì¶”ê°€í•˜ë©´ ë¨.
</script>

<!-- Smooth scroll (window) external + inline fallback with diag -->
<script src="/assets/js/scroll-ease.standalone.js" defer></script>
</body>
</html>
