<!DOCTYPE html>
<html lang="ko">
<head>
  <style>html { scroll-behavior: auto !important; }</style>
  <meta charset="UTF-8" />
  <title>Info | shovideo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --header-h: 56px;
      --bg: #0f1115;
      --panel: #1b1f2a;
      --text: #e9eef5;
      --muted: #9aa4b2;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: sans-serif;
      overflow-x: hidden; /* 1px 가로 스크롤 방지 */
    }
    header {
      position: sticky; top:0; z-index:1000;
      height: var(--header-h);
      display:flex; align-items:center; gap:8px;
      padding:0 12px; background:#111622;
      border-bottom:1px solid rgba(255,255,255,0.1);
    }
    header button {
      background:var(--panel); color:var(--text);
      border:none; padding:6px 12px; border-radius:8px; cursor:pointer;
    }
    /* 컨테이너: 80vw 기준, 내부 중앙 정렬 */
    #pdf-container {
      width: 80vw;
      margin: 0 auto;
      padding: 16px;
      min-height: calc(100vh - var(--header-h));
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center; /* 가로 중앙 */
    }
    /* PDF 페이지 캔버스: 등장 애니메이션 포함 */
    canvas {
      display: block;
      margin: 0 0 16px; /* 좌우 auto 제거 (플렉스에서 중앙정렬) */
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
      background: #fff;
      border-radius: 6px;
      opacity: 0;
      transform: translateY(40px);
      transition: opacity .6s ease, transform .6s ease;
    }
    canvas.show {
      opacity: 1;
      transform: translateY(0);
    }
  </style>
</head>
<body>
  <header>
    <button onclick="history.back()">← Back</button>
    <span style="margin-left:8px; font-weight:600;">Video Information</span>
    <button id="zoomOutBtn" aria-label="ZoomOut" style="margin-left:auto;">🔍–</button>
    <button id="zoomInBtn"  aria-label="ZoomIn">🔍+</button>
    <button id="fitBtn" aria-label="Fit to 80vw">⤢ Fit</button>
  </header>

  <main id="pdf-container" >Loading PDF...</main>

  <!-- Consolidated PDF.js logic -->
  <script type="module">
    import * as pdfjsLib from './pdfjs/pdf.mjs';
    pdfjsLib.GlobalWorkerOptions.workerSrc = './pdfjs/pdf.worker.mjs';

    // ===== 설정 =====
    const PDF_URL = '/assets/PDF/Are_you_sure.pdf';
    const container = document.getElementById('pdf-container');

    // 스케일 한계 (fit 모드에선 더 낮게 허용)
    const MIN_SCALE = 0.1;     // 수동 줌 최소
    const MAX_SCALE = 3.0;     // 최대 줌
    const DPR = Math.min(2, Math.max(1, window.devicePixelRatio || 1)); // 과한 뭉개짐 방지
    const ZOOM_STEP = 0.1;

    let pdfDoc = null;
    let basePageWidth = null;  // PDF 100% viewport width
    let scale = 1;
    let fitMode = true;        // true = 80vw 맞춤

    // ===== 유틸 =====
    const cssPx = (v) => `${Math.round(v * 100) / 100}px`; // 소수점 2자리
    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));

    function getInnerWidth(el){
      const cs = getComputedStyle(el);
      const pad = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
      // clientWidth는 패딩 포함 → 패딩 제외한 내부 컨텐츠 폭으로 변환
      return el.clientWidth - pad;
    }
    function clampScale(s, isFit = false){
      const min = isFit ? 0.05 : MIN_SCALE; // fit 상태에선 더 작게 허용
      return clamp(s, min, MAX_SCALE);
    }
    function computeScaleFit(){
      const w = getInnerWidth(container); // 80vw 내부폭
      if (!basePageWidth) return 1;
      return w / basePageWidth;
    }
    function debounce(fn, ms = 150){
      let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
    }

    // ===== 캔버스 등장 애니메이션 옵저버 (공용) =====
    const appearObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting){
          entry.target.classList.add('show');
          appearObserver.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });

    // ===== 렌더링 =====
    async function renderPage(pageNum){
      const page = await pdfDoc.getPage(pageNum);
      const viewport = page.getViewport({ scale });

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');

      const outScale = DPR;
      canvas.width  = Math.floor(viewport.width  * outScale);
      canvas.height = Math.floor(viewport.height * outScale);
      canvas.style.width  = cssPx(viewport.width);
      canvas.style.height = cssPx(viewport.height);

      const renderContext = {
        canvasContext: ctx,
        viewport,
        transform: outScale !== 1 ? [outScale, 0, 0, outScale, 0, 0] : null
      };

      await page.render(renderContext).promise;
      container.appendChild(canvas);
      appearObserver.observe(canvas);
    }

    async function renderAll(){
      container.innerHTML = '';
      for (let n = 1; n <= pdfDoc.numPages; n++){
        await renderPage(n);
      }
    }

    // 스크롤 위치 비율 보존(줌 시)
    function rememberScrollRatio(){
      const max = Math.max(1, document.body.scrollHeight - window.innerHeight);
      return window.scrollY / max;
    }
    function restoreScrollRatio(ratio){
      const max = Math.max(1, document.body.scrollHeight - window.innerHeight);
      window.scrollTo({ top: ratio * max, behavior: 'auto' });
    }

    // ===== 초기 로드 =====
    (async () => {
      try {
        pdfDoc = await pdfjsLib.getDocument(PDF_URL).promise;
        const page1 = await pdfDoc.getPage(1);
        basePageWidth = page1.getViewport({ scale: 1 }).width;

        // 80vw 내부폭 기준으로 fit 스케일 계산
        scale = clampScale(computeScaleFit(), true);
        await renderAll();
      } catch (e) {
        console.error(e);
        container.textContent = 'PDF load failed 😢';
      }
    })();

    // ===== 리사이즈(오직 fit 모드에서만 자동 재계산) =====
    const onResize = debounce(async () => {
      if (!pdfDoc || !basePageWidth || !fitMode) return;
      const nextFit = clampScale(computeScaleFit(), true);
      if (Math.abs(nextFit - scale) < 0.02) return;
      scale = nextFit;
      await renderAll();
    }, 200);
    window.addEventListener('resize', onResize);
    new ResizeObserver(onResize).observe(container);

    // ===== 컨트롤 =====
    const zoomInBtn  = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const fitBtn     = document.getElementById('fitBtn');

    async function doZoom(delta){
      fitMode = false; // 수동 모드
      const ratio = rememberScrollRatio();
      const next = clampScale(+(scale + delta).toFixed(2), false);
      if (Math.abs(next - scale) < 0.01) return;
      scale = next;
      await renderAll();
      restoreScrollRatio(ratio);
    }

    zoomInBtn?.addEventListener('click',  () => doZoom(+ZOOM_STEP));
    zoomOutBtn?.addEventListener('click', () => doZoom(-ZOOM_STEP));

    // Fit to 80vw
    fitBtn?.addEventListener('click', async () => {
      fitMode = true;
      scale = clampScale(computeScaleFit(), true);
      await renderAll();
      window.scrollTo({ top: 0 });
    });

    // Ctrl+0 → 80vw 기준 화면맞춤
    window.addEventListener('keydown', (e) => {
      if (e.key === '0' && (e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        fitMode = true;
        scale = clampScale(computeScaleFit(), true);
        renderAll().then(() => window.scrollTo({ top: 0 }));
      }
    });
  </script>



  <script>
    // ScrollEasing
(function(){
  if (window.__InertiaScrollInit) return;

  function initInertiaScroll(opts = {}) {
    // 접근성
    if (matchMedia('(prefers-reduced-motion: reduce)').matches) return;
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    if (isTouch && !opts.force) return;

    const docEl = document.scrollingElement || document.documentElement;
    const getHeaderOffset = () => {
      const v = parseInt(getComputedStyle(document.documentElement)
                 .getPropertyValue('--header-h'));
      return Number.isFinite(v) ? v : 0;
    };

    const {
      friction = 0.98,           // ↓ 낮을수록 빨리 멈춤(덜 미끄러짐) 0.85~0.97
      wheelBoost = 0.25,         // 휠 1틱당 가속도 배율(한 칸 이동량) 0.2~0.35
      maxSpeed = 16,             // 프레임당 최대 이동(px)
      keyStep = 56,              // 키보드 한 번 이동(px)
      pageStepRatio = 0.9,       // PageUp/Down 스텝 = 화면높이 * 비율
      wheelCap = 120,            // 과한 deltaY 캡(안정화)
      allowNativeInside = '[data-native-scroll], .scroll-native',
      force = false
    } = opts;

    let vy = 0;
    let rafId = null;

    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const maxScroll = () => Math.max(0, docEl.scrollHeight - innerHeight);

    function canScroll(el, delta){
      if (!el) return false;
      if (allowNativeInside && el.closest && el.closest(allowNativeInside)) return true;
      for (let n = el; n && n !== document.documentElement; n = n.parentElement){
        const cs = getComputedStyle(n);
        if ((cs.overflowY === 'auto' || cs.overflowY === 'scroll') && n.scrollHeight > n.clientHeight){
          if (delta > 0 && n.scrollTop + n.clientHeight < n.scrollHeight) return true;
          if (delta < 0 && n.scrollTop > 0) return true;
        }
      }
      return false;
    }

    function tick(){
      if (Math.abs(vy) > 0.02){
        vy *= friction;
        const step = clamp(vy, -maxSpeed, maxSpeed);
        const next = clamp(Math.round(docEl.scrollTop + step), 0, maxScroll());
        if (next !== docEl.scrollTop) docEl.scrollTop = next;
        rafId = requestAnimationFrame(tick);
      } else {
        vy = 0; rafId = null;
      }
    }

    // Wheel
    window.addEventListener('wheel', (e) => {
      const delta = e.deltaY || 0;
      if (!delta) return;
      if (canScroll(e.target, delta)) return; // 내부 스크롤 박스는 네이티브
      e.preventDefault();
      const d = clamp(delta, -wheelCap, wheelCap);
      vy += d * wheelBoost;
      if (!rafId) rafId = requestAnimationFrame(tick);
    }, { passive: false });

    // Keyboard
    window.addEventListener('keydown', (e) => {
      const tag = document.activeElement?.tagName?.toLowerCase();
      if (tag === 'input' || tag === 'textarea' || e.defaultPrevented) return;
      let add = 0, h = innerHeight;
      if (e.key === 'ArrowDown') add = +keyStep;
      else if (e.key === 'ArrowUp') add = -keyStep;
      else if (e.key === 'PageDown' || (e.key === ' ' && !e.shiftKey)) add = h * pageStepRatio;
      else if (e.key === 'PageUp'   || (e.key === ' ' &&  e.shiftKey)) add = -h * pageStepRatio;
      else if (e.key === 'Home') docEl.scrollTop = 0;
      else if (e.key === 'End')  docEl.scrollTop = maxScroll();
      if (add !== 0){ e.preventDefault(); vy += add; if (!rafId) rafId = requestAnimationFrame(tick); }
    }, { passive: false });

    // Anchor smooth scroll (헤더 오프셋 보정)
    document.addEventListener('click', (e) => {
      const a = e.target.closest && e.target.closest('a[href^="#"]');
      if (!a) return;
      const u = new URL(a.href, location.href);
      if (u.origin !== location.origin || u.pathname !== location.pathname || !u.hash) return;
      const id = decodeURIComponent(u.hash.slice(1));
      const el = document.getElementById(id); if (!el) return;
      e.preventDefault();
      const start = docEl.scrollTop;
      const y = start + el.getBoundingClientRect().top - getHeaderOffset();
      const dist = y - start;
      const dur = 520; const t0 = performance.now();
      const ease = (t)=> 1 - Math.pow(1 - t, 3); // easeOutCubic
      (function raf(now){
        const p = Math.min(1, (now - t0) / dur);
        docEl.scrollTop = Math.round(start + dist * ease(p));
        if (p < 1) requestAnimationFrame(raf);
      })(t0);
    });

    window.__InertiaScrollInit = true;
  }

  // 전역 노출 + 자동 초기화
  window.initInertiaScroll = initInertiaScroll;
  window.addEventListener('load', () => {
    if (!window.__InertiaScrollInit) initInertiaScroll({
      friction: 0.90,
      wheelBoost: 0.25,
      maxSpeed: 16,
      keyStep: 56,
      force: true,
      allowNativeInside: '[data-native-scroll], .scroll-native'
    });
  });
})();
</script>




</body>
</html>
