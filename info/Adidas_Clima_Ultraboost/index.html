<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Info | shovideo (Drag = real scrollbars)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <style>
    :root {
      --header-h: 56px;
      --bg: #0f1115;
      --panel: #1b1f2a;
      --text: #e9eef5;
      --muted: #9aa4b2;
      --zoom: 1;
      --tx: 0px;
      --ty: 0px;
      --zr-track: rgba(255,255,255,.22);
      --zr-track-hover: rgba(255,255,255,.32);
      --zr-thumb: #e9eef5;
      --zr-thumb-press: #ffffff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      overflow-x: hidden; }
    header{
      position: sticky; top: 0; z-index: 10000; isolation: isolate;
      display:flex; align-items:center; gap:8px;
      background:#111622; border-bottom:1px solid rgba(255,255,255,0.12);
      height: var(--header-h); padding: 0 12px;
    }
    header .spacer { flex: 1; }
    .zoom-ctrl { display:flex; align-items:center; gap:10px; margin-left:auto; }
    header button, .icon-btn {
      background:var(--panel); color:var(--text); border:none; padding:6px 12px; border-radius:8px; cursor:pointer;
      display:inline-flex; align-items:center; justify-content:center; gap:6px;
      transition: transform .06s ease, background .15s ease, opacity .15s ease;
    }
    .icon-btn:hover { background: #202636; }
    .icon-btn:active { transform: translateY(1px) scale(.98); }
    .icon-btn:disabled { opacity: .5; pointer-events: none; }
    .zoom-label { min-width: 48px; text-align: right; font-variant-numeric: tabular-nums; opacity: .9; }

    #pdf-container {
      width: 80vw; margin: 0 auto; padding: 16px;
      min-height: calc(100vh - var(--header-h));
      box-sizing: border-box; display: flex; flex-direction: column; align-items: center;
      overflow: visible; position: relative; z-index: 0;
      cursor: grab;
      user-select: none;
      -webkit-user-drag: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }
    #pdf-container.dragging { cursor: grabbing; }
    #pdf-stage {
      position: relative; z-index: 0;
      transform-origin: 0 0;
      transform: scale(var(--zoom)) translate(var(--tx), var(--ty)); /* scale ‚Üí translate */
      transition: transform .12s ease; will-change: transform; touch-action: none;
    }
    canvas { display:block; margin:0 0 16px; box-shadow:0 2px 8px rgba(0,0,0,.35);
      background:#fff; border-radius:6px; opacity:0; transform:translateY(40px);
      transition: opacity .6s ease, transform .6s ease; }
    canvas.show{ opacity:1; transform:translateY(0); }
    #pdf-stage.no-anim canvas{ opacity:1!important; transform:none!important; transition:none!important; }

    #zoomRange { -webkit-appearance: none; appearance: none; width: 200px; height: 28px; background: transparent; cursor: pointer; }
    #zoomRange::-webkit-slider-runnable-track { height: 6px; background: var(--zr-track); border-radius: 999px; transition: background .2s ease; }
    #zoomRange:hover::-webkit-slider-runnable-track { background: var(--zr-track-hover); }
    #zoomRange::-moz-range-track { height: 6px; background: var(--zr-track); border-radius: 999px; }
    #zoomRange:hover::-moz-range-track { background: var(--zr-track-hover); }
    #zoomRange::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 10px; height: 24px; margin-top: -9px;
      background: var(--zr-thumb); border-radius: 10px;
      box-shadow: 0 1px 2px rgba(0,0,0,.35);
      transition: transform .08s ease, background .15s ease, box-shadow .15s ease;
    }
    #zoomRange:active::-webkit-slider-thumb { transform: scale(0.96); background: var(--zr-thumb-press); }
    #zoomRange::-moz-range-thumb {
      width: 10px; height: 24px; background: var(--zr-thumb); border: none; border-radius: 10px;
      box-shadow: 0 1px 2px rgba(0,0,0,.35);
      transition: transform .08s ease, background .15s ease, box-shadow .15s ease;
    }
    #zoomRange:active::-moz-range-thumb { transform: scale(0.96); background: var(--zr-thumb-press); }
    #zoomRange:focus-visible { outline: 2px solid rgba(0,173,239,.65); outline-offset: 2px; border-radius: 10px; }
  </style>
</head>
<body>

<header>
  <button onclick="history.back()">‚Üê Back</button>
  <span style="margin-left:8px; font-weight:600;">Video Information</span>
  <div class="spacer"></div>
  <div class="zoom-ctrl">
    <span id="zoomLabel" class="zoom-label">100%</span>
    <input id="zoomRange" type="range" min="0.5" max="3" step="0.01" value="1" aria-label="Zoom slider" />
    <button id="zoomOutBtn" class="icon-btn" aria-label="Zoom out" title="Zoom out">
      <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
        <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="6"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
        </g>
      </svg>
    </button>
    <button id="zoomInBtn" class="icon-btn" aria-label="Zoom in" title="Zoom in">
      <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
        <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="6"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
        </g>
      </svg>
    </button>
    <button id="fitBtn" class="icon-btn" aria-label="Fit to viewport with margin" title="Fit">‚§¢</button>
  </div>
</header>

<main id="pdf-container">Loading PDF‚Ä¶</main>

<script type="module">
  // Lightweight loader (local first ‚Üí CDN fallback)
  const PDF_CDN = 'https://unpkg.com/pdfjs-dist@4.8.69/build';
  async function getPdfjs() {
    try { const mod = await import('./pdfjs/pdf.mjs'); return { pdfjsLib: mod, workerSrc: './pdfjs/pdf.worker.mjs' }; }
    catch { const mod = await import(PDF_CDN + '/pdf.mjs'); return { pdfjsLib: mod, workerSrc: PDF_CDN + '/pdf.worker.mjs' }; }
  }

  function folderFromPath() {
    let path = location.pathname.replace(/\/+$/, '');
    const parts = path.split('/').filter(Boolean);
    if (!parts.length) return '';
    let last = parts[parts.length - 1];
    if (/\.html?$/i.test(last)) { parts.pop(); last = parts[parts.length - 1] || ''; }
    return last;
  }
  const __FOLDER = folderFromPath();
  const PDF_URL = `/assets/PDF/${encodeURIComponent(__FOLDER)}.pdf`;

  const container = document.getElementById('pdf-container');
  const zoomRange = document.getElementById('zoomRange');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const fitBtn     = document.getElementById('fitBtn');
  const zoomLabel = document.getElementById('zoomLabel');

  const DPR = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
  let pdfDoc=null, basePageWidth=null, basePageHeight=null, fitScale=1;
  let zoom=1, pan={x:0,y:0};
  const HQ_ZOOM_THRESHOLD=1.2, HQ_DEBOUNCE_MS=200;
  let hqTimer=0, initialRendered=false;

  function cssPx(v){ return `${Math.round(v*100)/100}px`; }
  function applyTransformCSS(){
    document.documentElement.style.setProperty('--zoom', String(zoom));
    document.documentElement.style.setProperty('--tx', pan.x + 'px');
    document.documentElement.style.setProperty('--ty', pan.y + 'px');
  }
  function clampZoom(z){ return Math.min(3, Math.max(0.5, z)); }
  function centerOfContainer(){ const r=container.getBoundingClientRect(); return {x:r.left+r.width/2,y:r.top+r.height/2}; }

  // First-render fade-in only
  const appearObserver=new IntersectionObserver((entries)=>{
    entries.forEach(entry=>{ if(entry.isIntersecting){ entry.target.classList.add('show'); appearObserver.unobserve(entry.target); } });
  },{threshold:0.1});

  async function renderPage(pageNum, stage, scale=1, hq=false){
    const page=await pdfDoc.getPage(pageNum);
    const viewport=page.getViewport({ scale });
    const canvas=document.createElement('canvas');
    const ctx=canvas.getContext('2d');
    const scaleFactor = hq ? Math.min(2.5, DPR * Math.max(1, zoom)) : DPR;
    canvas.width = Math.floor(viewport.width * scaleFactor);
    canvas.height= Math.floor(viewport.height* scaleFactor);
    canvas.style.width  = cssPx(viewport.width);
    canvas.style.height = cssPx(viewport.height);
    const rc={ canvasContext:ctx, viewport };
    if (scaleFactor!==1) rc.transform=[scaleFactor,0,0,scaleFactor,0,0];
    await page.render(rc).promise;
    stage.appendChild(canvas);
    if(!initialRendered) appearObserver.observe(canvas); else canvas.classList.add('show');
  }
  function getStage(){
    let stage=document.getElementById('pdf-stage');
    if(!stage){ stage=document.createElement('div'); stage.id='pdf-stage'; container.innerHTML=''; container.appendChild(stage); }
    return stage;
  }
  async function renderAll(scale=fitScale, hq=false){
    const stage=getStage();
    if(hq) stage.classList.add('no-anim'); else stage.classList.remove('no-anim');
    stage.innerHTML='';
    for(let n=1;n<=pdfDoc.numPages;n++){ await renderPage(n, stage, scale, hq); }
  }

  function computeFitScaleWithMargin(){
    const header=document.querySelector('header');
    const headerH=header?header.clientHeight:56;
    const marginVH=Math.max(24, Math.round(window.innerHeight*0.06));
    const marginVW=Math.max(24, Math.round(window.innerWidth *0.06));
    const availW=Math.min(container.clientWidth, window.innerWidth - marginVW*2);
    const availH=Math.max(0, window.innerHeight - headerH - marginVH*2);
    const sW=availW/basePageWidth, sH=availH/basePageHeight;
    return Math.max(0.05, Math.min(sW, sH));
  }

  function syncUI(){
    if(zoomRange) zoomRange.value=String(+(zoom).toFixed(2));
    if(zoomLabel) zoomLabel.textContent=Math.round(zoom*100)+'%';
  }

  function zoomAt(newZoom, clientX, clientY){
    const stage=getStage();
    const rect=stage.getBoundingClientRect();
    newZoom=clampZoom(newZoom);
    // keep point (clientX, clientY) stationary
    const u=(clientX - rect.left - pan.x) / zoom;
    const v=(clientY - rect.top  - pan.y) / zoom;
    zoom=newZoom;
    pan.x = clientX - rect.left - u * zoom;
    pan.y = clientY - rect.top  - v * zoom;
    applyTransformCSS();
    scheduleHQCommit();
  }

  async function doHQCommit(){
    if (zoom < HQ_ZOOM_THRESHOLD) return;
    clearTimeout(hqTimer);
    const commitScale=fitScale*zoom;
    const stage=getStage();
    const oldScroll={x:window.scrollX,y:window.scrollY};
    stage.classList.add('no-anim');
    await renderAll(commitScale,true);
    applyTransformCSS();
    window.scrollTo(oldScroll.x, oldScroll.y);
    stage.classList.remove('no-anim');
  }
  function scheduleHQCommit(){
    clearTimeout(hqTimer);
    hqTimer=setTimeout(()=>doHQCommit(), HQ_DEBOUNCE_MS);
  }

  // Drag = real scrollbars (both axes)
  (function setupDragScroll(){
    let dragging=false, lastX=0, lastY=0;
    container.addEventListener('pointerdown', e=>{
      if (e.button!==0) return;
      dragging=true; lastX=e.clientX; lastY=e.clientY;
      container.classList.add('dragging');
      container.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    });
    container.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      // move scrollbars opposite to finger/mouse movement (trackpad-like)
      window.scrollBy({ left: -dx, top: -dy, behavior: 'auto' });
      lastX=e.clientX; lastY=e.clientY;
      e.preventDefault();
    }, {passive:false});
    ['pointerup','pointercancel','pointerleave'].forEach(type=>{
      container.addEventListener(type, e=>{
        dragging=false; container.classList.remove('dragging');
      });
    });
  })();

  // Wheel zoom (Ctrl/Cmd + wheel) ‚Äî center on pointer
  container.addEventListener('wheel', (e)=>{
    if (!e.ctrlKey && !e.metaKey) return;
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.0015); // smooth exponential
    const target = clampZoom(zoom * factor);
    zoomAt(target, e.clientX, e.clientY);
    syncUI();
  }, {passive:false});

  // Keyboard zoom (Ctrl/Cmd + '+'/'-'/'0')
  window.addEventListener('keydown', (e)=>{
    const meta = e.ctrlKey || e.metaKey;
    if (!meta) return;
    if (e.key === '0'){ e.preventDefault(); fitToViewport(true); syncUI(); return; }
    if (e.key === '+' || e.key === '=' || e.key === '-'){
      e.preventDefault();
      const center = { x: window.innerWidth/2, y: window.innerHeight/2 };
      const step = e.key === '-' ? 1/1.1 : 1.1;
      zoomAt(clampZoom(zoom * step), center.x, center.y);
      syncUI();
    }
  });

  // Slider zoom ‚Äî center on container
  zoomRange?.addEventListener('input', (e)=>{
    const center = centerOfContainer();
    zoomAt(parseFloat(e.target.value), center.x, center.y);
    syncUI();
  });

  // Buttons
  zoomInBtn?.addEventListener('click', ()=>{
    const center = centerOfContainer();
    zoomAt(clampZoom(zoom*1.1), center.x, center.y);
    syncUI();
  });
  zoomOutBtn?.addEventListener('click', ()=>{
    const center = centerOfContainer();
    zoomAt(clampZoom(zoom/1.1), center.x, center.y);
    syncUI();
  });
  fitBtn?.addEventListener('click', ()=>{ fitToViewport(true); syncUI(); });

  async function fitToViewport(forceHQ=false){
    fitScale=computeFitScaleWithMargin();
    // Fit ÏÉÅÌÉú: ÎÇ¥Î∂Ä zoom 1, pan 0 ‚Äî Î†åÎçî Ïä§ÏºÄÏùºÎ°ú ÎßûÏ∂§
    zoom=1; pan={x:0,y:0}; applyTransformCSS();
    if (!initialRendered) initialRendered=true;
    await renderAll(fitScale,false);
  }

  // Init
  (async ()=>{
    try{
      const { pdfjsLib, workerSrc } = await getPdfjs();
      pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;

      pdfDoc=await pdfjsLib.getDocument(PDF_URL).promise;
      const page1=await pdfDoc.getPage(1);
      const vp1=page1.getViewport({ scale: 1 });
      basePageWidth = vp1.width; basePageHeight = vp1.height;

      await fitToViewport(false);
      // Base stage size for bounds (if later needed)
      const rect0=getStage().getBoundingClientRect();
      // __baseStageW/H are not used for drag-scroll-only flow; keep measured if needed
      // const __baseStageW = rect0.width; const __baseStageH = rect0.height;

      initialRendered=true;
      syncUI();
    }catch(e){
      console.error(e);
      document.getElementById('pdf-container').textContent='PDF load failed üò¢';
    }
  })();
</script>

<!-- Smooth scroll (optional) -->
<script src="/assets/js/scroll-ease.standalone.js" defer></script>

</body>
</html>
