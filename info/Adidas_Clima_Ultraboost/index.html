<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Info | shovideo (Drag scrolls dedicated viewport)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <style>
    :root {
      --header-h: 56px;
      --bg: #0f1115;
      --panel: #1b1f2a;
      --text: #e9eef5;
      --muted: #9aa4b2;
      --zoom: 1;
      --tx: 0px;
      --ty: 0px;
      --zr-track: rgba(255,255,255,.22);
      --zr-track-hover: rgba(255,255,255,.32);
      --zr-thumb: #e9eef5;
      --zr-thumb-press: #ffffff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      overflow: hidden; /* 스크롤은 전용 뷰포트에서만 */ }
    header{
      position: sticky; top: 0; z-index: 10000; isolation: isolate;
      display:flex; align-items:center; gap:8px;
      background:#111622; border-bottom:1px solid rgba(255,255,255,0.12);
      height: var(--header-h); padding: 0 12px;
    }
    header .spacer { flex: 1; }
    .zoom-ctrl { display:flex; align-items:center; gap:10px; margin-left:auto; }
    header button, .icon-btn {
      background:var(--panel); color:var(--text); border:none; padding:6px 12px; border-radius:8px; cursor:pointer;
      display:inline-flex; align-items:center; justify-content:center; gap:6px;
      transition: transform .06s ease, background .15s ease, opacity .15s ease;
    }
    .icon-btn:hover { background: #202636; }
    .icon-btn:active { transform: translateY(1px) scale(.98); }
    .icon-btn:disabled { opacity: .5; pointer-events: none; }
    .zoom-label { min-width: 48px; text-align: right; font-variant-numeric: tabular-nums; opacity: .9; }

    /* 레이아웃 컨테이너 (스크롤 없음) */
    #pdf-container {
width: 100vw;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  display: flex; flex-direction: column; align-items: stretch;
  position: relative; z-index: 0;
  min-height: calc(100dvh - var(--header-h));
}
    /* 실제 스크롤은 여기서만 발생 */
    #pdf-viewport {
width: 100%;
  height: calc(100vh - var(--header-h));
  height: calc(100svh - var(--header-h));
  height: calc(100dvh - var(--header-h));
  overflow: auto; overscroll-behavior: contain;
  position: relative;
  border-radius: 0;
  background: transparent;
  box-shadow: none;
  cursor: grab;
  user-select: none;
  -webkit-user-select: none;
  -webkit-user-drag: none;
}
    #pdf-viewport.dragging { cursor: grabbing; }

    #pdf-stage {
      position: relative; z-index: 0;
      transform-origin: 0 0;
      transform: scale(var(--zoom)) translate(var(--tx), var(--ty)); /* scale → translate */
      transition: transform .12s ease; will-change: transform; touch-action: none;
    }
    canvas { display:block; margin:0 0 16px; box-shadow:0 2px 8px rgba(0,0,0,0.35);
      background:#fff; border-radius:6px; opacity:0; transform:translateY(40px);
      transition: opacity .6s ease, transform .6s ease; }
    canvas.show{ opacity:1; transform:translateY(0); }
    #pdf-stage.no-anim canvas{ opacity:1!important; transform:none!important; transition:none!important; }

    #zoomRange { -webkit-appearance: none; appearance: none; width: 200px; height: 28px; background: transparent; cursor: pointer; }
    #zoomRange::-webkit-slider-runnable-track { height: 6px; background: var(--zr-track); border-radius: 999px; transition: background .2s ease; }
    #zoomRange:hover::-webkit-slider-runnable-track { background: var(--zr-track-hover); }
    #zoomRange::-moz-range-track { height: 6px; background: var(--zr-track); border-radius: 999px; }
    #zoomRange:hover::-moz-range-track { background: var(--zr-track-hover); }
    #zoomRange::-webkit-slider-thumb {
      -webkit-appearance: none; appearance: none;
      width: 10px; height: 24px; margin-top: -9px;
      background: var(--zr-thumb); border-radius: 10px;
      box-shadow: 0 1px 2px rgba(0,0,0,.35);
      transition: transform .08s ease, background .15s ease, box-shadow .15s ease;
    }
    #zoomRange:active::-webkit-slider-thumb { transform: scale(0.96); background: var(--zr-thumb-press); }
    #zoomRange::-moz-range-thumb {
      width: 10px; height: 24px; background: var(--zr-thumb); border: none; border-radius: 10px;
      box-shadow: 0 1px 2px rgba(0,0,0,.35);
      transition: transform .08s ease, background .15s ease, box-shadow .15s ease;
    }
    #zoomRange:active::-moz-range-thumb { transform: scale(0.96); background: var(--zr-thumb-press); }
    #zoomRange:focus-visible { outline: 2px solid rgba(0,173,239,.65); outline-offset: 2px; border-radius: 10px; }
  </style>
</head>
<body>

<header>
  <button onclick="history.back()">← Back</button>
  <span style="margin-left:8px; font-weight:600;">Video Information</span>
  <div class="spacer"></div>
  <div class="zoom-ctrl">
    <span id="zoomLabel" class="zoom-label">100%</span>
    <input id="zoomRange" type="range" min="0.5" max="3" step="0.01" value="1" aria-label="Zoom slider" />
    <button id="zoomOutBtn" class="icon-btn" aria-label="Zoom out" title="Zoom out">
      <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
        <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="6"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/>
        </g>
      </svg>
    </button>
    <button id="zoomInBtn" class="icon-btn" aria-label="Zoom in" title="Zoom in">
      <svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true">
        <g fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="11" cy="11" r="6"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/>
        </g>
      </svg>
    </button>
    <button id="fitBtn" class="icon-btn" aria-label="Fit to viewport with margin" title="Fit">⤢</button>
  </div>
</header>

<main id="pdf-container">
  <div id="pdf-viewport">
    <div id="pdf-stage"></div>
  </div>
</main>

<script type="module">
  // PDF.js loader (local → CDN)
  const PDF_CDN = 'https://unpkg.com/pdfjs-dist@4.8.69/build';
  async function getPdfjs() {
    try { const mod = await import('./pdfjs/pdf.mjs'); return { pdfjsLib: mod, workerSrc: './pdfjs/pdf.worker.mjs' }; }
    catch { const mod = await import(PDF_CDN + '/pdf.mjs'); return { pdfjsLib: mod, workerSrc: PDF_CDN + '/pdf.worker.mjs' }; }
  }

  function folderFromPath() {
    let path = location.pathname.replace(/\/+$/, '');
    const parts = path.split('/').filter(Boolean);
    if (!parts.length) return '';
    let last = parts[parts.length - 1];
    if (/\.html?$/i.test(last)) { parts.pop(); last = parts[parts.length - 1] || ''; }
    return last;
  }
  const __FOLDER = folderFromPath();
  const PDF_URL = `/assets/PDF/${encodeURIComponent(__FOLDER)}.pdf`;

  const container = document.getElementById('pdf-container');
  const viewport  = document.getElementById('pdf-viewport');
  const stage     = document.getElementById('pdf-stage');

  const zoomRange = document.getElementById('zoomRange');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const fitBtn     = document.getElementById('fitBtn');
  const zoomLabel = document.getElementById('zoomLabel');

  const DPR = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
  let pdfDoc=null, basePageWidth=null, basePageHeight=null, fitScale=1;
  let zoom=1, pan={x:0,y:0};
  const HQ_ZOOM_THRESHOLD=1.2, HQ_DEBOUNCE_MS=200;
  let hqTimer=0, initialRendered=false;

  function cssPx(v){ return `${Math.round(v*100)/100}px`; }
  function applyTransformCSS(){
    document.documentElement.style.setProperty('--zoom', String(zoom));
    document.documentElement.style.setProperty('--tx', pan.x + 'px');
    document.documentElement.style.setProperty('--ty', pan.y + 'px');
  }
  function clampZoom(z){ return Math.min(3, Math.max(0.5, z)); }
  function centerOfViewport(){ const r=viewport.getBoundingClientRect(); return {x:r.left+r.width/2,y:r.top+r.height/2}; }

  // First-render fade-in only
  const appearObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add("show");
      appearObserver.unobserve(entry.target);
    }
  });
}, { root: document.getElementById("pdf-viewport"), rootMargin: "0px 0px -20% 0px", threshold: 0.01 });
appearObserver.unobserve(entry.target); } });
  },{threshold:0.1});

  async function renderPage(pageNum, scale=1, hq=false){
    const page=await pdfDoc.getPage(pageNum);
    const viewportPdf=page.getViewport({ scale });
    const canvas=document.createElement('canvas');
    const ctx=canvas.getContext('2d');
    const scaleFactor = hq ? Math.min(2.5, DPR * Math.max(1, zoom)) : DPR;
    canvas.width = Math.floor(viewportPdf.width * scaleFactor);
    canvas.height= Math.floor(viewportPdf.height* scaleFactor);
    canvas.style.width  = cssPx(viewportPdf.width);
    canvas.style.height = cssPx(viewportPdf.height);
    const rc={ canvasContext:ctx, viewport: viewportPdf };
    if (scaleFactor!==1) rc.transform=[scaleFactor,0,0,scaleFactor,0,0];
    await page.render(rc).promise;
    stage.appendChild(canvas);
if (!initialRendered) { appearObserver.observe(canvas); } else { canvas.classList.add("show"); }
  }
  async function renderAll(scale=fitScale, hq=false){
    if(hq) stage.classList.add('no-anim'); else stage.classList.remove('no-anim');
    stage.innerHTML='';
    for(let n=1;n<=pdfDoc.numPages;n++){ await renderPage(n, scale, hq); }
  }

  function computeFitScaleWithMargin(){
  const header = document.querySelector("header");
  const headerH = header ? header.clientHeight : 56;
  const availW = container.clientWidth;
  const availH = Math.max(0, window.innerHeight - headerH);
  const sW = availW / basePageWidth, sH = availH / basePageHeight;
  return Math.max(0.05, Math.min(sW, sH));
}

  function syncUI(){
    if(zoomRange) zoomRange.value=String(+(zoom).toFixed(2));
    if(zoomLabel) zoomLabel.textContent=Math.round(zoom*100)+'%';
  }

  function zoomAt(newZoom, clientX, clientY){
    const rect=stage.getBoundingClientRect();
    newZoom=clampZoom(newZoom);
    const u=(clientX - rect.left - pan.x) / zoom;
    const v=(clientY - rect.top  - pan.y) / zoom;
    zoom=newZoom;
    pan.x = clientX - rect.left - u * zoom;
    pan.y = clientY - rect.top  - v * zoom;
    applyTransformCSS();
    scheduleHQCommit();
  }

  async function doHQCommit(){
  clearTimeout(hqTimer);
  if (zoom < 1) return;
  const commitScale = fitScale * Math.max(1, zoom);
  const old = { x: viewport.scrollLeft, y: viewport.scrollTop };
  stage.classList.add("no-anim");
  await renderAll(commitScale, true);
  applyTransformCSS();
  viewport.scrollTo(old.x, old.y);
  stage.classList.remove("no-anim");
};
    stage.classList.add('no-anim');
    await renderAll(commitScale,true);
    applyTransformCSS();
    viewport.scrollTo(old.x, old.y);
    stage.classList.remove('no-anim');
  }
  function scheduleHQCommit(){
  clearTimeout(hqTimer);
  if (zoom < 1) return;
  hqTimer = setTimeout(() => doHQCommit(), HQ_DEBOUNCE_MS);
}

  // Drag = real scrollbars (both axes) on the dedicated viewport
  (function setupDragScroll(){
    let dragging=false, lastX=0, lastY=0;
    viewport.addEventListener('pointerdown', e=>{
      if (e.button!==0) return;
      dragging=true; lastX=e.clientX; lastY=e.clientY;
      viewport.classList.add('dragging');
      viewport.setPointerCapture?.(e.pointerId);
      e.preventDefault();
    });
    viewport.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      viewport.scrollBy({ left: -dx, top: -dy, behavior: 'auto' });
      lastX=e.clientX; lastY=e.clientY;
      e.preventDefault();
    }, {passive:false});
    ['pointerup','pointercancel','pointerleave'].forEach(type=>{
      viewport.addEventListener(type, e=>{
        dragging=false; viewport.classList.remove('dragging');
      });
    });
  })();

  // Wheel zoom (Ctrl/Cmd + wheel) — pointer-centered
  viewport.addEventListener('wheel', (e)=>{
    if (!e.ctrlKey && !e.metaKey) return;
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.0015);
    const target = clampZoom(zoom * factor);
    zoomAt(target, e.clientX, e.clientY);
    syncUI();
  }, {passive:false});

  // Keyboard zoom (Ctrl/Cmd + +/-/0)
  window.addEventListener('keydown', (e)=>{
    const meta = e.ctrlKey || e.metaKey;
    if (!meta) return;
    if (e.key === '0'){ e.preventDefault(); fitToViewport(true); syncUI(); return; }
    if (e.key === '+' || e.key === '=' || e.key === '-'){
      e.preventDefault();
      const center = centerOfViewport();
      const step = e.key === '-' ? 1/1.1 : 1.1;
      zoomAt(clampZoom(zoom * step), center.x, center.y);
      syncUI();
    }
  });

  // Slider zoom — center on viewport
  zoomRange?.addEventListener('input', (e)=>{
    const center = centerOfViewport();
    zoomAt(parseFloat(e.target.value), center.x, center.y);
    syncUI();
  });
  // Buttons
  zoomInBtn?.addEventListener('click', ()=>{
    const center = centerOfViewport();
    zoomAt(clampZoom(zoom*1.1), center.x, center.y); syncUI();
  });
  zoomOutBtn?.addEventListener('click', ()=>{
    const center = centerOfViewport();
    zoomAt(clampZoom(zoom/1.1), center.x, center.y); syncUI();
  });
  fitBtn?.addEventListener('click', ()=>{ fitToViewport(true); syncUI(); });

  async function fitToViewport(forceHQ=false){
  fitScale = computeFitScaleWithMargin();
  zoom = 1; pan = {x:0,y:0}; applyTransformCSS();
  await renderAll(fitScale, false);
  if (!initialRendered) initialRendered = true;
  viewport.scrollTo({ left: 0, top: 0, behavior: "auto" });
}; applyTransformCSS();
    if (!initialRendered) initialRendered=true;
    await renderAll(fitScale,false);
    // 중앙 정렬처럼 보이도록 스크롤 최상단으로
    viewport.scrollTo({ left: 0, top: 0, behavior: 'auto' });
  }

  // Init
  (async ()=>{
    try{
      const { pdfjsLib, workerSrc } = await getPdfjs();
      pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;
      const doc = await pdfjsLib.getDocument(PDF_URL).promise;
      pdfDoc = doc;
      const page1=await pdfDoc.getPage(1);
      const vp1=page1.getViewport({ scale: 1 });
      basePageWidth = vp1.width; basePageHeight = vp1.height;

      await fitToViewport(false);
      initialRendered=true;
      syncUI();
    }catch(e){
      console.error(e);
      document.getElementById('pdf-container').textContent='PDF load failed 😢';
    }
  })();
</script>

</body>
</html>
