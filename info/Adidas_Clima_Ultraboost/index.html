<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Info | shovideo (HQ Zoom + Pan + FitMargin + CenterZoom)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark light">
  <style>
    :root {
      --header-h: 56px;
      --bg: #0f1115;
      --panel: #1b1f2a;
      --text: #e9eef5;
      --muted: #9aa4b2;
      /* CSS-only preview transform state */
      --zoom: 1;
      --tx: 0px;
      --ty: 0px;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      overflow-x: hidden;
    }
    header {
      position: sticky; top:0; z-index:1000;
      height: var(--header-h);
      display:flex; align-items:center; gap:8px;
      padding:0 12px; background:#111622;
      border-bottom:1px solid rgba(255,255,255,0.1);
    }
    header button {
      background:var(--panel); color:var(--text);
      border:none; padding:6px 12px; border-radius:8px; cursor:pointer;
    }
    #pdf-container {
      width: 80vw;
      margin: 0 auto;
      padding: 16px;
      min-height: calc(100vh - var(--header-h));
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: visible;
    }
    /* Stage: preview via CSS translate + scale */
    #pdf-stage {
      transform-origin: 0 0; /* left-top makes pan math simple */
      transform:
        translate(var(--tx), var(--ty))
        scale(var(--zoom));
      transition: transform .15s ease;
      will-change: transform;
      touch-action: none; /* we handle pinch/pan */
    }
    /* Canvas appearance animation (initial only) */
    canvas {
      display: block;
      margin: 0 0 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.35);
      background: #fff;
      border-radius: 6px;
      opacity: 0;
      transform: translateY(40px);
      transition: opacity .6s ease, transform .6s ease;
    }
    canvas.show {
      opacity: 1;
      transform: translateY(0);
    }
    /* Disable appear animation during HQ re-render */
    #pdf-stage.no-anim canvas {
      opacity: 1 !important;
      transform: none !important;
      transition: none !important;
    }
    #zoomRange { accent-color: #00adef; }
  </style>
</head>
<body>

<!-- Inline smooth scroll (hard wheel intercept) -->
<script>
(function(){
  if (window.__ScrollEaseHard) return;
  window.__ScrollEaseHard = true;
  const ROOT = document.scrollingElement || document.documentElement;
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const friction  = 0.85;
  const wheelBoost= 0.12;
  const maxSpeed  = 10;
  const wheelCap  = 60;
  const stopEps   = 0.16;
  function isScrollable(el, dy){
    if (!el || el === document || el === document.documentElement) return false;
    const cs = getComputedStyle(el);
    if (!(cs.overflowY === 'auto' || cs.overflowY === 'scroll')) return false;
    if (el.scrollHeight <= el.clientHeight + 1) return false;
    if (dy > 0)  return el.scrollTop + el.clientHeight < el.scrollHeight;
    if (dy < 0)  return el.scrollTop > 0;
    return true;
  }
  function findHost(target, dy){
    for (let n = target; n; n = n.parentElement){
      if (isScrollable(n, dy)) return n;
    }
    return ROOT;
  }
  let host = ROOT, vy = 0, raf = 0;
  const max = (el) => el === ROOT
    ? Math.max(0, ROOT.scrollHeight - innerHeight)
    : Math.max(0, el.scrollHeight - el.clientHeight);
  function tick(){
    if (Math.abs(vy) > stopEps){
      vy *= friction;
      const step = clamp(vy, -maxSpeed, maxSpeed);
      const next = clamp(Math.round(host.scrollTop + step), 0, max(host));
      if (next !== host.scrollTop) host.scrollTop = next;
      raf = requestAnimationFrame(tick);
    } else {
      vy = 0; raf = 0;
    }
  }
  function onWheel(e){
    const raw = e.deltaY || 0; if (!raw) return;
    host = findHost(e.target, raw) || ROOT;
    e.preventDefault();
    const d = clamp(raw, -wheelCap, wheelCap);
    vy += d * wheelBoost;
    if (!raf) raf = requestAnimationFrame(tick);
  }
  [window, document, document.documentElement].forEach(t=>{
    t && t.addEventListener('wheel', onWheel, { capture:true, passive:false });
  });
  function attachBody(){
    if (document.body)
      document.body.addEventListener('wheel', onWheel, { capture:true, passive:false });
  }
  if (document.body) attachBody();
  else document.addEventListener('DOMContentLoaded', attachBody, { once:true });
})();
</script>

<header>
  <button onclick="history.back()">‚Üê Back</button>
  <span style="margin-left:8px; font-weight:600;">Video Information</span>
  <input id="zoomRange" type="range" min="0.5" max="3" step="0.01" value="1"
         style="width:180px; margin:0 8px;" aria-label="Zoom slider" />
  <button id="zoomOutBtn" aria-label="ZoomOut" style="margin-left:auto;">üîç‚Äì</button>
  <button id="zoomInBtn"  aria-label="ZoomIn">üîç+</button>
  <button id="fitBtn" aria-label="Fit to viewport with margin">‚§¢ Fit</button>
</header>

<main id="pdf-container">Loading PDF‚Ä¶</main>

<script type="module">
  import * as pdfjsLib from './pdfjs/pdf.mjs';
  pdfjsLib.GlobalWorkerOptions.workerSrc = './pdfjs/pdf.worker.mjs';

  // ---- path helpers ----
  function __folderFromPath() {
    let path = location.pathname.replace(/\/+$/, '');
    const parts = path.split('/').filter(Boolean);
    if (!parts.length) return '';
    let last = parts[parts.length - 1];
    if (/\.html?$/i.test(last)) { parts.pop(); last = parts[parts.length - 1] || ''; }
    return last;
  }
  const __FOLDER = __folderFromPath();
  const PDF_URL = `/assets/PDF/${encodeURIComponent(__FOLDER)}.pdf`;

  const container = document.getElementById('pdf-container');

  // ---- render basic (fit to viewport with margins) ----
  const DPR = Math.min(2, Math.max(1, window.devicePixelRatio || 1));
  let pdfDoc = null;
  let basePageWidth = null;
  let basePageHeight = null;
  let fitScale = 1; // computed fit scale

  // preview state
  let zoom = 1;                // CSS zoom (== --zoom)
  let pan = { x: 0, y: 0 };    // CSS pan  (== --tx/--ty)

  // HQ commit settings
  const HQ_ZOOM_THRESHOLD = 1.2;   // only commit HQ if zoom is big enough
  const HQ_DEBOUNCE_MS = 220;
  let hqTimer = 0;

  // initial render flag ‚Üí appear animation only then
  let initialRendered = false;

  function cssPx(v){ return `${Math.round(v*100)/100}px`; }

  // Apply CSS variables for transform
  function applyTransformCSS() {
    document.documentElement.style.setProperty('--zoom', String(zoom));
    document.documentElement.style.setProperty('--tx', pan.x + 'px');
    document.documentElement.style.setProperty('--ty', pan.y + 'px');
  }

  // Appearing animation observer (used only on initial render)
  const appearObserver = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting){
        entry.target.classList.add('show');
        appearObserver.unobserve(entry.target);
      }
    });
  }, { threshold: 0.1 });

  async function renderPage(pageNum, stage, scale=1, hq=false) {
    const page = await pdfDoc.getPage(pageNum);
    const viewport = page.getViewport({ scale });

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    // scaleFactor: higher when doing HQ commit, capped to avoid memory blowups
    const scaleFactor = hq ? Math.min(2.5, DPR * Math.max(1, zoom)) : DPR;

    canvas.width  = Math.floor(viewport.width  * scaleFactor);
    canvas.height = Math.floor(viewport.height * scaleFactor);
    canvas.style.width  = cssPx(viewport.width);
    canvas.style.height = cssPx(viewport.height);

    const renderContext = { canvasContext: ctx, viewport };
    if (scaleFactor !== 1) renderContext.transform = [scaleFactor, 0, 0, scaleFactor, 0, 0];

    await page.render(renderContext).promise;
    stage.appendChild(canvas);

    // appear animation only on the very first render
    if (!initialRendered) appearObserver.observe(canvas);
    else {
      canvas.classList.add('show'); // ensure visible without transition
    }
  }

  function getStage() {
    let stage = document.getElementById('pdf-stage');
    if (!stage) {
      stage = document.createElement('div');
      stage.id = 'pdf-stage';
      container.innerHTML = '';
      container.appendChild(stage);
    }
    return stage;
  }

  async function renderAll(scale=fitScale, hq=false) {
    const stage = getStage();
    if (hq) stage.classList.add('no-anim'); else stage.classList.remove('no-anim');
    stage.innerHTML = '';
    for (let n=1; n<=pdfDoc.numPages; n++) {
      await renderPage(n, stage, scale, hq);
    }
  }

  // Compute fit scale with viewport margins (leave breathing room)
  function computeFitScaleWithMargin() {
    const header = document.querySelector('header');
    const headerH = header ? header.clientHeight : 56;
    const marginVH = Math.max(24, Math.round(window.innerHeight * 0.06)); // ~6vh or >=24px
    const marginVW = Math.max(24, Math.round(window.innerWidth  * 0.06)); // ~6vw or >=24px

    const availW = Math.min(container.clientWidth, window.innerWidth - marginVW * 2);
    const availH = Math.max(0, window.innerHeight - headerH - marginVH * 2);

    const scaleByW = availW / basePageWidth;
    const scaleByH = availH / basePageHeight;
    return Math.max(0.05, Math.min(scaleByW, scaleByH));
  }

  // Fit action: recompute fitScale, reset zoom/pan, HQ commit
  async function fitToViewport(forceHQ=false) {
    fitScale = computeFitScaleWithMargin();
    zoom = 1;
    pan = { x: 0, y: 0 };
    applyTransformCSS();
    if (forceHQ) {
      await doHQCommit(true); // force
    }
  }

  (async () => {
    try {
      pdfDoc = await pdfjsLib.getDocument(PDF_URL).promise;
      const page1 = await pdfDoc.getPage(1);
      const vp1 = page1.getViewport({ scale: 1 });
      basePageWidth = vp1.width;
      basePageHeight = vp1.height;

      fitScale = computeFitScaleWithMargin();
      await renderAll(fitScale, /*hq*/ false);
      zoom = 1; pan = {x:0, y:0};
      applyTransformCSS(); // initial transform

      initialRendered = true; // appear animation only for first render
    } catch (e) {
      console.error(e);
      container.textContent = 'PDF load failed üò¢';
    }
  })();

// ===== Zoom-around-point helper (REPLACE THIS FUNCTION) =====
function zoomAt(newZoom, clientX, clientY) {
  const stage = getStage();
  const rect = stage.getBoundingClientRect();

  // Ï†úÌïú
  newZoom = Math.max(0.5, Math.min(3, newZoom));

  // (clientX, clientY) ÏßÄÏ†êÏùò ÏΩòÌÖêÏ∏† Ï¢åÌëú(u, v) Í≥ÑÏÇ∞
  const u = (clientX - rect.left - pan.x) / zoom;
  const v = (clientY - rect.top  - pan.y) / zoom;

  // ÏÉà Ï§åÏóêÏÑú Ìï¥Îãπ Ï†êÏù¥ Í∞ôÏùÄ ÌôîÎ©¥ Ï¢åÌëúÏóê ÎÇ®ÎèÑÎ°ù pan Î≥¥Ï†ï
  zoom  = newZoom;
  pan.x = clientX - rect.left - u * zoom;
  pan.y = clientY - rect.top  - v * zoom;

  applyTransformCSS();
  scheduleHQCommit();
}


  // ===== Zoom preview + HQ commit =====
  function scheduleHQCommit(force=false) {
    clearTimeout(hqTimer);
    if (!force && zoom < HQ_ZOOM_THRESHOLD) return; // skip HQ if small zoom
    hqTimer = setTimeout(() => doHQCommit(), HQ_DEBOUNCE_MS);
  }

  async function doHQCommit(force=false) {
    const commitScale = fitScale * zoom;
    const stage = getStage();
    const oldScroll = { x: window.scrollX, y: window.scrollY };
    stage.classList.add('no-anim');
    await renderAll(commitScale, /*hq*/ true);
    applyTransformCSS();
    window.scrollTo(oldScroll.x, oldScroll.y);
    stage.classList.remove('no-anim');
  }

  // ===== Controls =====
  const zoomRange = document.getElementById('zoomRange');
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const fitBtn = document.getElementById('fitBtn');

  function centerOfContainer() {
    const rect = container.getBoundingClientRect();
    return { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
  }

  function syncUI() { zoomRange.value = String(zoom); }

  zoomRange.addEventListener('input', e => {
    const { x, y } = centerOfContainer();
    zoomAt(parseFloat(e.target.value), x, y);
    syncUI();
  });
  zoomInBtn.addEventListener('click', () => {
    const { x, y } = centerOfContainer();
    zoomAt(zoom + 0.1, x, y);
    syncUI();
  });
  zoomOutBtn.addEventListener('click', () => {
    const { x, y } = centerOfContainer();
    zoomAt(zoom - 0.1, x, y);
    syncUI();
  });
  fitBtn.addEventListener('click', async () => {
    await fitToViewport(true); // force HQ so it‚Äôs crisp
    syncUI();
  });

  // prevent browser page zoom for our shortcuts
  window.addEventListener('keydown', (e) => {
    const meta = e.ctrlKey || e.metaKey;
    if (!meta) return;
    if (e.key === '0') {
      e.preventDefault();
      fitToViewport(true);
      syncUI();
    }
    if (e.key === '+' || e.key === '=' || e.key === '-') {
      e.preventDefault();
      const { x, y } = centerOfContainer();
      zoomAt(zoom + (e.key === '-' ? -0.1 : +0.1), x, y);
      syncUI();
    }
  });

  // Ctrl/‚åò + wheel ‚Üí center on pointer
  container.addEventListener('wheel', (e) => {
    if (!e.ctrlKey && !e.metaKey) return;
    e.preventDefault();
    const factor = 1 + (-Math.sign(e.deltaY) * 0.12);
    zoomAt(zoom * factor, e.clientX, e.clientY);
    syncUI();
  }, { passive: false });

  // ===== Pinch zoom (two pointers) & Pan (single finger) =====
  const pointers = new Map();
  let pinchStartDist = 0, pinchStartZoom = 1;
  let pinchCenter = { x: 0, y: 0 };
  let isPanning = false;
  let panStart = null;

  function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
  function mid(a,b){ return { x: (a.x+b.x)/2, y: (a.y+b.y)/2 }; }

  container.addEventListener('pointerdown', (e) => {
    container.setPointerCapture?.(e.pointerId);
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if (pointers.size === 2) {
      const [p1, p2] = Array.from(pointers.values());
      pinchStartDist = dist(p1,p2);
      pinchStartZoom = zoom;
      pinchCenter = mid(p1,p2);
      isPanning = false;
    } else if (pointers.size === 1) {
      panStart = { x: e.clientX - pan.x, y: e.clientY - pan.y };
      isPanning = true;
    }
  });

  // ===== Pinch zoom (two pointers) & Pan (single finger) =====
  container.addEventListener('pointermove', (e) => {
    if (!pointers.has(e.pointerId)) return;
    pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  
    if (pointers.size === 2) {
      // pinch around midpoint
      const [p1, p2] = Array.from(pointers.values());
      const k = dist(p1, p2) / (pinchStartDist || 1);
      const targetZoom = Math.max(0.5, Math.min(3, pinchStartZoom * k));
  
      // ‚úÖ Ï§ëÏ†ê Ï¢åÌëú Í∑∏ÎåÄÎ°ú ÎÑòÍπÄ ‚Üí X/Y Î™®Îëê Ï†ïÌôïÌûà Í≥†Ï†ï
      zoomAt(targetZoom, pinchCenter.x, pinchCenter.y);
      syncUI();
    } else if (pointers.size === 1 && isPanning) {
      pan.x = e.clientX - panStart.x;
      pan.y = e.clientY - panStart.y;
      applyTransformCSS();
      scheduleHQCommit();
      e.preventDefault();
    }
  }, { passive: false });


  ['pointerup','pointercancel','pointerleave'].forEach(t => {
    container.addEventListener(t, (e) => {
      pointers.delete(e.pointerId);
      if (pointers.size < 2) { pinchStartDist = 0; }
      if (pointers.size === 0) { isPanning = false; }
    });
  });

  // Double tap / double click: toggle fit <-> 2x zoom at tap point
  (function(){
    let lastTap = 0;
    container.addEventListener('dblclick', async (e) => {
      e.preventDefault();
      const nearFit = Math.abs(zoom - 1) < 0.02;
      if (!nearFit) {
        await fitToViewport(true);
      } else {
        zoomAt(2, e.clientX, e.clientY);
      }
      syncUI();
    });
    // iOS double-tap zoom block inside stage only
    container.addEventListener('touchend', (e) => {
      if (!e.target.closest('#pdf-stage')) return;
      const now = Date.now();
      if (now - lastTap < 300) e.preventDefault();
      lastTap = now;
    }, { passive:false });
    if ('ongesturestart' in window) {
      ['gesturestart','gesturechange','gestureend'].forEach(ev => {
        container.addEventListener(ev, (e) => {
          if (!e.target.closest('#pdf-stage')) return;
          e.preventDefault();
        }, { passive:false });
      });
    }
  })();

  // Refit on resize (re-render only when fit size changes)
  const onResize = (() => {
    let t;
    return () => {
      clearTimeout(t);
      t = setTimeout(async () => {
        if (!pdfDoc) return;
        const nextFit = computeFitScaleWithMargin();
        if (Math.abs(nextFit - fitScale) < 0.02) return;
        fitScale = nextFit;
        await renderAll(fitScale, /*hq*/ false);
        applyTransformCSS();
      }, 200);
    };
  })();
  window.addEventListener('resize', onResize);
  new ResizeObserver(onResize).observe(container);
</script>

</body>
</html>
